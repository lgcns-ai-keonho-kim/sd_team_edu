# 01. 문자열 파이프라인 전략

## 이 챕터에서 다루는 내용

- LLM 텍스트 출력의 불확실성 이해
- 파싱 → 검증 → 정규화 파이프라인
- 실제 코드로 설계하는 방법

---

## 1. 왜 파이프라인이 필요한가?

LLM은 다음과 같은 문제를 자주 일으킵니다.

- 출력 형식이 들쭉날쭉함
- 기대하지 않은 단어가 섞임
- 대소문자/공백/구두점 차이

따라서 문자열을 바로 사용하면 오류가 누적됩니다. 해결책은 **파이프라인**입니다.

---

## 2. 파이프라인의 3단계

1. **파싱(Parsing)**: 원본 텍스트에서 필요한 정보만 추출
2. **검증(Validation)**: 허용 가능한 값인지 확인
3. **정규화(Normalization)**: 표준 표현으로 통일

이 3단계를 "반드시" 거친다는 규칙을 팀 전체에 적용하면, LLM 출력으로 인한 장애를 크게 줄일 수 있습니다.

---

## 3. 파이썬 기반 파이프라인 설계 예시

아래 코드는 LLM 출력 처리에 사용할 파이프라인을 만든 예시입니다.
설계 패턴은 **전략(Strategy)**에 가깝습니다.

```python
"""
목적: 텍스트 파싱/검증/정규화를 하나의 파이프라인으로 제공한다.
설명: 규칙 기반 문자열 처리를 통해 안정성을 확보한다.
디자인 패턴: Strategy
참조: docs/03_llm_text_handling/01_문자열_파이프라인_전략.md
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class TextPipeline:
    """LLM 출력 문자열을 처리하는 파이프라인."""

    allowed: set[str]

    def parse(self, raw_text: str) -> str:
        """원본 텍스트에서 핵심 값을 추출한다."""
        return raw_text.strip()

    def validate(self, parsed: str) -> None:
        """허용된 값인지 검증한다."""
        if parsed not in self.allowed:
            raise ValueError(f"허용되지 않은 값: {parsed}")

    def normalize(self, parsed: str) -> str:
        """표준 표현으로 정규화한다."""
        return parsed.upper()

    def run(self, raw_text: str) -> str:
        """파이프라인을 순차적으로 실행한다."""
        parsed = self.parse(raw_text)
        self.validate(parsed)
        return self.normalize(parsed)
```

### LangGraph와 연결하는 예시 (개념)

```python
pipeline = TextPipeline(allowed={"yes", "no"})
result = pipeline.run(" yes ")
```

### LangGraph 노드로 감싸는 예시

```python
"""
목적: 문자열 파이프라인을 LangGraph 노드로 제공한다.
설명: 텍스트 처리 결과를 상태에 기록한다.
디자인 패턴: Adapter
참조: src/examples/text_pipeline.py
"""

from dataclasses import dataclass
from langgraph.graph import StateGraph, END
from src.examples.text_pipeline import TextPipeline

PipelineState = dict[str, str]


@dataclass(frozen=True)
class TextPipelineNode:
    """문자열 파이프라인을 그래프 노드로 감싼다."""

    pipeline: TextPipeline

    def build(self) -> StateGraph:
        """파이프라인 노드를 포함한 그래프를 만든다."""
        graph = StateGraph(PipelineState)
        graph.add_node("normalize", self._normalize)
        graph.add_edge("normalize", END)
        graph.set_entry_point("normalize")
        return graph

    def _normalize(self, state: PipelineState) -> PipelineState:
        """원본 텍스트를 정규화한다."""
        normalized = self.pipeline.run(state["raw_text"])
        return {**state, "normalized": normalized}
```

---

## 4. 구현 체크리스트

- 파싱/검증/정규화 함수가 분리되어 있는가?
- 허용 값 목록과 표준 표현이 정의되어 있는가?
- 파싱 실패가 예외로 명확히 처리되는가?
- 정규화 결과가 다운스트림에서 바로 사용 가능한가?
