# 03. 프롬프트 개선 루프와 평가

## 이 챕터에서 배우는 것

- 프롬프트는 한 번에 완성되지 않는다는 사실
- 개선 루프(설계 → 실행 → 평가 → 개선)의 구조
- 초보자도 할 수 있는 간단한 평가 기준 만들기

---

## 1. 왜 개선 루프가 필요한가?

LLM은 확률적 모델입니다. 따라서 같은 프롬프트라도 결과 품질이 조금씩 다를 수 있습니다.

이때 중요한 것은 **테스트 데이터**와 **평가 기준**을 미리 정의하는 것입니다.

- 테스트 데이터: 실제 사용 상황과 유사한 입력 예시 5~10개
- 평가 기준: 정답성, 형식 일치, 길이, 금지어 포함 여부

이 기준이 없으면 프롬프트를 개선해도 "좋아졌는지" 판단할 수 없습니다.

---

## 2. 개선 루프의 단계

1. **설계**: 목표와 출력 형식을 정의
2. **실행**: 테스트 입력에 대해 출력 생성
3. **평가**: 체크리스트 기준으로 점검
4. **개선**: 실패 패턴을 기준으로 수정

이 과정을 짧게 반복하는 것이 가장 빠른 학습 방법입니다.

---

## 3. LangChain 기반 프롬프트 버전 관리 예시

아래 코드는 **프롬프트 버전 레지스트리**를 만들어, 버전별 프롬프트를 관리하는 예시입니다.
설계 패턴은 **레지스트리(Registry)**이며, 실무에서는 레지스트리를 보통 단일 인스턴스로 사용합니다.

```python
"""
목적: 프롬프트 버전을 명시적으로 관리한다.
설명: 버전별 템플릿을 등록하고 필요한 버전을 선택한다.
디자인 패턴: Registry
참조: docs/01_prompt_engineering/03_프롬프트_개선_루프와_평가.md
"""

from langchain_core.prompts import PromptTemplate


class PromptVersionRegistry:
    """버전별 프롬프트 템플릿을 제공하는 레지스트리."""

    def __init__(self, templates: dict[str, PromptTemplate]) -> None:
        """버전별 프롬프트 템플릿을 등록한다."""
        self._templates = templates

    def get_template(self, version: str) -> PromptTemplate:
        """버전 키에 해당하는 프롬프트 템플릿을 반환한다.

        Args:
            version: 조회할 프롬프트 버전 키.

        Returns:
            PromptTemplate: 입력 변수(context)를 포함한 템플릿.
        """
        if version not in self._templates:
            raise ValueError(f"알 수 없는 버전: {version}")
        return self._templates[version]
```

### 사용 예 (개념)

```python
prompt_v1 = """역할: 요약가
목표: 입력 내용을 3줄로 간결하게 요약
규칙: 중복 제거, 추측 금지, 핵심만 선택
입력:
{context}
출력 형식:
요약1: <한 줄>
요약2: <한 줄>
요약3: <한 줄>"""

prompt_v2 = """역할: 요약가
목표: 핵심 3문장을 자연스러운 문장으로 요약
규칙: 너무 자세한 설명 금지, 중립적 어조 유지
입력:
{context}
출력 형식:
요약: <3문장>"""

template_v1 = PromptTemplate(
    template=prompt_v1,
    input_variables=["context"],
)
template_v2 = PromptTemplate(
    template=prompt_v2,
    input_variables=["context"],
)

registry = PromptVersionRegistry(
    templates={
        "v1": template_v1,
        "v2": template_v2,
    }
)

prompt = registry.get_template("v2")
text = prompt.format(context="긴 문서 내용...")
```

---

## 4. v1/v2 동시 호출과 비교 분석 전략

프롬프트는 **같은 입력에 대해 동시에 실행**해 비교해야 개선 방향이 명확해집니다.
아래 전략을 따르면 초보자도 안전하게 A/B 평가를 수행할 수 있습니다.

### 핵심 원칙

- **동일 입력 세트**에 대해 v1과 v2를 모두 실행한다.
- 출력 형식 위반 여부를 **가장 먼저** 확인한다.
- 평가 기준을 **정량 + 정성**으로 분리한다.

### 비교 평가 지표 예시

- 형식 일치: 출력 형식 규칙을 지켰는가?
- 핵심성: 핵심 정보만 담았는가?
- 간결성: 불필요한 설명이 없는가?
- 일관성: 동일 입력에서 변동이 적은가?

### 동시 호출 예시 (개념)

```python
"""
목적: v1과 v2 프롬프트를 동일 입력으로 비교한다.
설명: 같은 데이터셋에 대해 출력 품질을 평가한다.
디자인 패턴: Registry
참조: docs/01_prompt_engineering/03_프롬프트_개선_루프와_평가.md
"""

from dataclasses import dataclass
from langchain_core.prompts import PromptTemplate


@dataclass(frozen=True)
class PromptABComparer:
    """두 프롬프트를 동일 입력으로 비교한다."""

    registry: "PromptVersionRegistry"

    def compare(self, contexts: list[str]) -> list[dict[str, str]]:
        """v1/v2를 동일 입력으로 실행한 결과를 모은다."""
        v1 = self.registry.get_template("v1")
        v2 = self.registry.get_template("v2")
        results: list[dict[str, str]] = []
        for context in contexts:
            results.append(
                {
                    "input": context,
                    "v1": v1.format(context=context),
                    "v2": v2.format(context=context),
                }
            )
        return results
```

### 비교 분석 절차

1. 테스트 입력 5~10개 준비(실제 사용 패턴과 유사하게 구성)
2. v1/v2를 동일 입력으로 실행
3. 형식 위반 여부를 먼저 체크
4. 핵심성/간결성/일관성 기준으로 점수화
5. 점수와 실패 패턴을 기준으로 프롬프트 수정

이 과정을 반복하면 \"감\"이 아니라 **근거 기반 개선**이 가능합니다.

---

## 5. 구현 체크리스트

- 출력 형식이 명확히 지켜졌는가?
- 금지어 또는 불필요한 설명이 포함되었는가?
- 출력 길이가 요구조건을 넘지 않는가?
- 동일 입력에 대해 심각한 변동이 있는가?

이 체크리스트는 **정성적 평가**이지만, 초보자가 가장 빠르게 프롬프트 품질을 개선할 수 있는 방법입니다.
