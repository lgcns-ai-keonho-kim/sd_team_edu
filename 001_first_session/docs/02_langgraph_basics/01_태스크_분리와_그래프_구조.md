# 01. 태스크 분리와 그래프 구조

## 이 챕터에서 다루는 내용

- LangGraph의 기본 개념(노드, 엣지, 상태)
- **태스크 분리**가 왜 중요한지
- 가장 단순한 그래프 설계 예시

---

## 1. 태스크 분리는 왜 필요한가?

초보자들이 자주 하는 실수는 "한 번의 LLM 호출로 모든 걸 끝내려는 것"입니다.

하지만 실제 서비스에서는 작업을 분리해야 다음 문제가 해결됩니다.

- 출력 실패 시 어느 단계가 문제인지 알 수 있다.
- 특정 단계만 재사용하거나 개선할 수 있다.
- 각 단계별 검증 로직을 독립적으로 설계할 수 있다.

LangGraph는 이런 분리를 **그래프 구조로 표현**하게 도와줍니다.

---

## 2. LangGraph의 핵심 개념

- **상태(State)**: 노드들이 공유하는 데이터 구조
- **노드(Node)**: 입력 상태를 받아 상태를 갱신하는 함수
- **엣지(Edge)**: 노드 간 실행 순서

즉, "입력 → 상태 → 노드 → 상태 → 다음 노드"가 반복되는 구조입니다.

---

## 2-1. START 노드와 entry point의 차이

LangGraph에서는 그래프의 시작점을 두 가지 방식으로 이해할 수 있습니다.

### START 노드(개념적 시작점)

- 그래프 실행이 시작되는 **논리적 출발점**을 의미합니다.
- 학습용 다이어그램이나 문서에서 흐름을 명확히 보여줄 때 유용합니다.
- 실제 코드에서는 **START를 명시적으로 쓰지 않아도** 동작합니다.

### entry point(코드상의 시작점)

- `set_entry_point("노드명")`으로 **실제 시작 노드**를 지정합니다.
- LangGraph는 이 설정을 기준으로 실행을 시작합니다.
- 따라서 entry point가 있으면 START를 별도 노드로 만들 필요는 없습니다.

### 언제 START를 문서에 적어야 하는가?

- 교육 자료에서 흐름을 시각화할 때는 START를 명시하면 이해가 쉽습니다.
- 코드 구현에서는 entry point만 정확히 지정하면 충분합니다.

---

## 3. LangGraph 기반 샘플 코드

아래 코드는 "전처리 → 감정 분류"로 태스크를 분리한 가장 작은 그래프 예시입니다.
설계 패턴은 **파이프라인(Pipeline)**에 가깝습니다.

```python
"""
목적: 전처리와 분류 태스크를 분리한 그래프를 만든다.
설명: 상태(State)를 중심으로 노드를 연결한다.
디자인 패턴: Pipeline
참조: docs/02_langgraph_basics/01_태스크_분리와_그래프_구조.md
"""

from dataclasses import dataclass
from langgraph.graph import StateGraph, END

ReviewState = dict[str, str]


@dataclass(frozen=True)
class ReviewGraphBuilder:
    """리뷰 처리 그래프를 생성하는 빌더."""

    def build(self) -> StateGraph:
        """전처리-분류 그래프를 생성한다.

        Returns:
            StateGraph: 실행 가능한 그래프 객체.
        """
        graph = StateGraph(ReviewState)
        graph.add_node("preprocess", self._preprocess)
        graph.add_node("classify", self._classify)
        graph.add_edge("preprocess", "classify")
        graph.add_edge("classify", END)
        graph.set_entry_point("preprocess")
        return graph

    def _preprocess(self, state: ReviewState) -> ReviewState:
        """리뷰 텍스트를 간단히 정리한다."""
        cleaned = state["raw_text"].strip()
        return {**state, "cleaned_text": cleaned}

    def _classify(self, state: ReviewState) -> ReviewState:
        """감정 분류 결과를 상태에 기록한다.

        실제 프로젝트에서는 LLM 호출이 이 위치에 들어간다.
        """
        sentiment = "중립" if "하지만" in state["cleaned_text"] else "긍정"
        return {**state, "sentiment": sentiment}
```

### 사용 예 (개념)

```python
builder = ReviewGraphBuilder()
graph = builder.build().compile()
result = graph.invoke({"raw_text": "품질은 좋지만 배송이 느렸어요"})
```

---

## 4. 초보자를 위한 설계 팁

- 노드 하나는 **하나의 책임**만 가진다.
- 상태는 최소한의 필드만 유지한다.
- 각 노드는 "입력 → 출력"이 명확해야 한다.

태스크 분리가 제대로 되어 있으면, 이후의 확장도 매우 쉬워집니다.

---

## 5. 구현 체크리스트

- 노드 하나가 하나의 책임만 가지는가?
- 상태(State)가 최소 필드로 구성되었는가?
- 엔트리 포인트와 종료(END)가 명확한가?
- 실패 시 상태에 오류 정보가 기록되는가?
