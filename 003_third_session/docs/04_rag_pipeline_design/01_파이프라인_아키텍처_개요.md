# 01. 파이프라인 아키텍처 개요

## 이 챕터에서 배우는 것

- RAG 파이프라인의 전체 구조 (서비스 수준)
- 03_rag_postprocessing의 설계 요소 반영 방식
- 단계별 역할과 입력/출력 인터페이스
- 운영 관점의 폴백/지표 기준

---

## 1. 전체 파이프라인 흐름

검색 → 메타데이터 정책 필터 → 정규화/병합 → 후처리 → 생성 → 스트리밍

> 핵심 원칙: **정책/권한 필터를 가장 먼저** 적용한다.

---

## 2. 검색 전략 사전 명기(필수)

검색 전략은 **실행 중에 결정하는 것이 아니라**, 서비스 설계 시점에 **문서로 고정**해야 합니다.
아래 항목을 먼저 명시한 뒤 파이프라인을 설계합니다.

- **사용할 전략 목록**: 쿼리 분해, 검색-검증-병합, 적응형 HyDE 중 어떤 것을 쓸지
- **적용 조건**: 어떤 질문/도메인에서 적용할지
- **비용 상한**: 추가 LLM 호출/검색 횟수 제한

> 전략이 확정되면, `retrieve` 노드 내부에서 병렬 검색 흐름으로 구현합니다.

---

## 3. 그래프 기반 설계 개요

서비스 수준에서는 **State Machine 그래프**로 파이프라인을 구성하는 것이 안전합니다.
각 단계는 **노드(Node)**로 표현되고, 노드는 **명확한 입력/출력 상태**를 가집니다.

### 핵심 노드 목록

- `retrieve`: 검색 수행(리트리버)
- `policy_filter`: 권한/언어/버전 필터
- `normalize`: 점수 정규화(거리 → 유사도)
- `merge`: 결과 병합
- `postprocess`: 중복 제거/다양성/재정렬/압축
- `generate`: LLM 답변 생성
- `stream_answer`: 답변 토큰 스트리밍(응답 노드)
- `stream_sources`: 근거 문서 스트리밍(근거 노드)

---

## 4. 설계 원칙

- **단일 책임**: 각 단계는 한 가지 역할만 가진다
- **인터페이스 우선**: 입력/출력 스키마를 먼저 고정한다
- **정책 우선**: 메타데이터/권한/버전을 먼저 처리한다
- **정규화 필수**: 점수 스케일을 맞춘 뒤 병합한다
- **근거 추적**: 생성 단계까지 `source_id`를 유지한다
- **전략 선결정**: 적용할 검색 전략을 문서로 먼저 고정한다

---

## 5. 단계별 역할

1) **검색**
   - 리트리버(retriever)로 후보 문서 수집

2) **정책 기반 필터(우선)**
   - 권한/언어/버전 기준 필터 적용

3) **정규화 + 병합**
   - 점수 스케일 통일(거리 → 유사도)
   - 정규화 후 `score_type`을 `similarity`로 고정
   - 다중 검색 결과 병합

4) **후처리**
   - 중복 제거, 다양성 확보, 재정렬, 컨텍스트 압축

5) **생성**
   - 근거 기반 답변 생성

6) **스트리밍**
   - 답변 토큰 → 근거 문서 순서로 스트리밍

---

## 6. 데이터 인터페이스

### 1) 검색 출력 표준

- `doc_id`: 내부 식별자
- `content`: 본문 텍스트
- `metadata`: 메타데이터(권한/카테고리 등)
- `score`: 점수
- `score_type`: `distance` 또는 `similarity`
- `source_id`: 원문 식별자

```json
{
  "doc_id": 1001,
  "content": "환불 정책 안내 ...",
  "metadata": {"category": "policy", "language": "ko"},
  "score": 0.23,
  "score_type": "distance",
  "source_id": "policy:refund"
}
```

### 2) 생성 입력 표준

- `question`: 사용자 질문
- `contexts`: 최종 컨텍스트
- `constraints`: 출력 제한(스타일/길이/정책)

---

## 7. 폴백 전략

- 정책 필터 실패 → **공개 문서만 허용** 또는 **차단**
- 검색 결과 없음 → **적응형 HyDE** 수행
- 후처리 결과 없음 → **안전 응답** 반환

---

## 8. 운영 지표(필수)

- **정확도/누락률**: 정답 문서 포함 비율
- **지연 시간**: P50/P95 레이턴시
- **비용**: LLM 호출 수, 토큰 사용량
- **실패율**: 검색/후처리/생성 단계별 실패율

---

## 9. 그래프 기반 파이프라인

```python
"""
목적: 서비스 수준 파이프라인 흐름을 정리한다.
설명: 정책 필터 → 정규화 → 병합 → 후처리 → 생성 순서로 처리한다.
디자인 패턴: Pipeline
"""

from langgraph.graph import StateGraph, END


def build_pipeline_graph() -> StateGraph:
    """서비스 파이프라인 그래프를 구성한다."""
    graph = StateGraph(dict)
    graph.add_node("retrieve", node_retrieve)
    graph.add_node("policy_filter", node_policy_filter)
    graph.add_node("normalize", node_normalize)
    graph.add_node("merge", node_merge)
    graph.add_node("postprocess", node_postprocess)
    graph.add_node("generate", node_generate)
    graph.add_node("stream_answer", node_stream_answer)
    graph.add_node("stream_sources", node_stream_sources)

    graph.set_entry_point("retrieve")
    graph.add_edge("retrieve", "policy_filter")
    graph.add_edge("policy_filter", "normalize")
    graph.add_edge("normalize", "merge")
    graph.add_edge("merge", "postprocess")
    graph.add_edge("postprocess", "generate")
    graph.add_edge("generate", "stream_answer")
    graph.add_conditional_edges(
        "stream_answer",
        should_stream_sources,
        {True: "stream_sources", False: END},
    )
    graph.add_edge("stream_sources", END)
    return graph
```

> `stream_answer`와 `stream_sources`는 **서로 다른 노드**로 분리하고,  
> `stream_sources`는 **컨텍스트가 존재할 때만** 실행하도록 조건 분기를 둡니다.

---

## 10. 흔한 실수

- 정책 필터가 뒤로 밀려 **보안 위험** 발생
- 점수 스케일이 섞여 **병합 편향** 발생
- `source_id`가 유지되지 않아 **근거 추적 실패**

---

## 11. 체크리스트

- 정책 필터가 최우선으로 적용되는가?
- `score_type`을 포함한 스키마가 정의되었는가?
- 정규화 이후 병합이 수행되는가?
- 후처리 기준이 문서화되었는가?
- 폴백 경로가 있는가?
