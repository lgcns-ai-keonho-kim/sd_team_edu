# 03. 메타데이터 필터링 기초

## 이 챕터에서 배우는 것

- 메타데이터 필터링의 역할과 적용 시점
- 사전 필터와 사후 필터의 차이
- 필터 설계를 위한 큰 구성 요소
- 서비스 관점에서 반드시 필요한 정책 요소

---

## 1. 메타데이터 필터링이 중요한 이유

메타데이터 필터링은 **검색 대상 자체를 제한**하는 작업입니다.
검색 정확도뿐 아니라 **보안/권한**을 결정하기 때문에 필수적인 설계 요소입니다.

- **권한 분리**: 내부 문서가 외부 사용자에게 노출되지 않도록 제한
- **도메인 구분**: 정책/가이드/FAQ 같은 문서 범주 구분
- **시간 조건**: 유효 기간이 지난 문서 제외
- **언어 조건**: 사용자 언어와 일치하는 문서만 제공

---

## 2. 사전 필터 vs 사후 필터

### 1) 사전 필터(Pre-Filter)

- 검색 **이전에** 후보를 제한
- 정확도/속도 모두에 유리
- 실무 기본 선택

### 2) 사후 필터(Post-Filter)

- 검색 **이후에** 결과를 제거
- 유연하지만 비용 증가
- 사전 필터로 처리하기 어려운 조건에 사용

#### 사전/사후 필터 SQL 차이(개념)

```sql
-- 사전 필터: 후보를 먼저 줄인다
SELECT id, content
FROM documents
WHERE metadata->>'category' = 'policy'
ORDER BY embedding <=> :query_vector
LIMIT 5;

-- 사후 필터: 먼저 검색 후 조건에 맞는 것만 남긴다
SELECT id, content
FROM documents
ORDER BY embedding <=> :query_vector
LIMIT 50;  -- 더 크게 조회 후 애플리케이션에서 필터링
```

---

## 3. 큰 구성 요소(요소 단위)

### 1) 필터 정책(Filter Policy)

- 어떤 조건이 **필수**인지 정의
- 예: 내부 사용자만 `access_level=internal` 허용

### 2) 필터 표현식(Filter Expression)

- 정책을 실제 검색 조건으로 변환한 표현
- 검색 엔진/라이브러리에 맞게 표현 방식이 달라짐

### 3) 권한 모델(Access Control)

- 사용자 역할/조직/계약 상태에 따라 조건을 강제
- 필터 누락은 보안 사고로 이어짐

### 4) 메타데이터 품질(Metadata Quality)

- 필터는 **정확하고 안정적인 메타데이터**가 전제
- 불안정한 필드는 필터 정확도를 흔듦

---

## 4. 메타데이터 설계 기준(개요)

- **불변 속성**을 우선 사용(카테고리, 권한, 문서 타입)
- **파생 속성**은 최소화(자동 태그 등)
- 변경 가능성이 높으면 **버전 관리**가 필요

### 성능 관점 보강(권장)

- JSONB 필터가 잦다면 **GIN 인덱스**를 고려한다
- 필터 핵심 필드는 **물리 컬럼 분리**가 가장 안정적

```sql
-- 목적: JSONB 메타데이터 필터 성능을 개선한다.
CREATE INDEX idx_documents_metadata_gin
ON documents
USING GIN (metadata);
```

---

## 5. 필터 적용 흐름

1) 사용자 컨텍스트 확인(권한/언어/조직)
2) 필터 정책 결정
3) 검색 조건 생성
4) 검색 수행
5) 사후 필터(필요 시)

---

## 6. 예시

아래 코드는 **필터 정책 → 표현식 변환**의 흐름만 보여줍니다.
검색 엔진/DB는 생략합니다.

```python
"""
목적: 필터 정책을 표현식으로 변환한다.
설명: 필수 조건을 누락 없이 포함한다.
디자인 패턴: Builder
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class UserContext:
    """사용자 컨텍스트."""

    access_level: str
    language: str


def build_filter(ctx: UserContext, category: str | None) -> dict:
    """필터 표현식을 생성한다."""
    filters: dict = {
        "access_level": ctx.access_level,
        "language": ctx.language,
    }
    if category:
        filters["category"] = category
    return filters
```

---

## 7. 설계 시 고려해야 할 질문

- 필수 필터와 선택 필터를 구분했는가?
- 권한 필터가 항상 적용되는가?
- 필터가 검색 품질을 과도하게 제한하지 않는가?
- 메타데이터 품질을 보장할 수 있는가?

---

## 8. 권한 필터 실패 시 폴백 정책

권한 필터는 **필수 조건**입니다. 실패했을 때는 “검색을 더 열어주는 것”이 아니라
**더 보수적인 응답**으로 전환해야 합니다.

### 1) 기본 원칙

- 필터 실패는 **보안 실패**로 간주한다
- 검색 결과를 줄이는 방향으로만 폴백한다
- 사용자에게는 최소한의 안내만 제공한다

### 2) 권장 폴백 흐름

1) 권한 필터 적용 실패 감지
2) 검색 결과 **차단** 또는 **공개 문서만** 허용
3) 사용자 메시지는 “권한 제한으로 일부 결과만 제공” 수준으로 안내
4) 운영 로그/알림에 반드시 기록

**사용자 안내 문구 예시**

- "권한 제한으로 인해 일부 결과만 제공됩니다."

### 3) 간단 예시

```python
"""
목적: 권한 필터 실패 시 안전한 폴백을 적용한다.
설명: 공개 문서만 허용하도록 강제한다.
디자인 패턴: Policy
"""

def apply_safe_fallback(filters: dict, has_access: bool) -> dict:
    """권한 실패 시 공개 범위로 필터를 축소한다."""
    if has_access:
        return filters
    safe_filters = dict(filters)
    safe_filters["access_level"] = "public"
    return safe_filters
```

---

## 9. 흔한 실수

- 권한 필터 누락으로 민감 문서 노출
- 필터 기준이 불안정해 검색 결과가 흔들림
- 필터 조건이 과도해 검색 결과가 비어버림

---

## 10. 체크리스트

- 필터 정책이 문서화되었는가?
- 권한 필터가 강제되는가?
- 사전/사후 필터 기준이 구분되었는가?
- 메타데이터 품질 기준이 있는가?
