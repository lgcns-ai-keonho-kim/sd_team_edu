# 02. 하이브리드 검색 개요

## 이 챕터에서 배우는 것

- 하이브리드 검색이 필요한 이유와 적용 시점
- 하이브리드 검색의 큰 구성 요소
- 점수 결합 방식(가중합/RRF/재정렬)의 차이
- 설계 시 고려해야 할 품질/비용/지연 시간 기준

---

## 1. 하이브리드 검색이 필요한 이유

벡터 검색만으로는 아래 상황을 잘 해결하지 못합니다.
하이브리드 검색은 **의미 검색(벡터) + 키워드 검색(BM25)**을 결합해 약점을 보완합니다.

- **정확한 키워드가 필요한 경우**: 상품 코드, 에러 코드, 고유 명사
- **숫자/버전 정보가 중요한 경우**: 날짜, 버전, 수치 기준
- **의미는 유사하지만 핵심 단어가 빠지는 경우**
- **신규 문서가 적어 벡터 의미가 약한 경우**

> 결론: 하이브리드는 “의미 기반”과 “정확한 키워드 매칭”을 함께 확보하기 위한 전략입니다.

---

## 2. 큰 구성 요소(요소 단위)

하이브리드 검색은 아래 요소를 분리해서 설계합니다.

### 1) 키워드 검색기(Keyword Retriever)

- BM25 기반 검색 엔진 또는 라이브러리로 구현
- 정확한 용어/숫자/코드에 강함

### 2) 벡터 검색기(Vector Retriever)

- 벡터 스토어(vector store)/검색 엔진 기반 **유사도 또는 거리 점수** 검색
- 의미 유사성에 강함

### 3) 후보 병합기(Candidate Merger)

- 두 검색기의 결과를 합쳐 중복 제거
- source_id 기준 중복 제거가 일반적

### 4) 점수 정규화기(Score Normalizer)

- 벡터 점수(유사도/거리)와 키워드 점수(BM25)의 스케일 차이를 보정
- 정규화 없이는 특정 검색기가 결과를 독점할 수 있음

### 5) 결합 전략(Fusion Strategy)

- 가중합, RRF, 재정렬 등
- 서비스 목표(정확도/속도)에 따라 선택

### 6) 재정렬기(Optional Reranker)

- 상위 N개 결과만 재정렬해 품질을 올림
- 비용 대비 효과가 큰 구간에서만 사용

### 7) 메타데이터 필터

- 권한/카테고리/기간 필터를 먼저 적용해야 품질이 안정됨
- 자세한 내용은 `03_메타데이터_필터링_기초.md` 참고

---

## 3. 결합 전략의 종류와 특징

### 1) 가중합(Weighted Sum)

- 정규화된 점수에 가중치를 적용해 합산
- 장점: 직관적, 튜닝 쉬움
- 단점: 점수 스케일 불일치 시 왜곡 가능

```text
final_score = w1 * vector_score + w2 * keyword_score
```

### 2) RRF(Reciprocal Rank Fusion)

- 각 검색기의 **순위 기반 점수**를 합산
- 장점: 스케일 차이를 무시 가능
- 단점: 순위만 보고 점수 정보를 잃음

```text
rrf_score = 1 / (k + rank)
```

### 3) 재정렬(Rerank)

- 상위 N개 결과만 LLM/크로스 인코더로 재정렬
- 장점: 정확도 크게 향상
- 단점: 비용/지연 시간 증가

#### 점수 정규화 방식 간단 비교

- **Min-Max 스케일링**: 0~1로 맞추기 쉬움, 이상치에 민감
- **Z-Score**: 평균/분산 기준 정규화, 분포가 안정적일 때 유리
- **순위 기반 정규화**: 점수 대신 순위 사용, 스케일 차이를 무시 가능
- **거리 점수 주의**: 벡터 점수가 거리라면 먼저 유사도로 변환 후 결합한다

#### 재정렬 적용 기준(실무 가이드)

- **Top-N 제한**: N=20~50 범위에서 시작
- **비용 상한**: 요청당 토큰/초과 지출 상한 설정
- **지연 시간 상한**: P95 목표 지연 시간을 넘으면 비활성화

---

## 4. 하이브리드 검색 흐름

1) 사용자 질의 수신
2) 메타데이터 필터 적용
3) 키워드 검색 수행
4) 벡터 검색 수행
5) 점수 정규화
6) 결합 전략 적용
7) 중복 제거 및 Top-K 반환

> 메타데이터 필터를 **두 검색기에 동일하게 적용**하는 것이 중요합니다.

---

## 5. 간단 예시

아래 예시는 **하이브리드 결합 구조만 보여주는 최소 코드**입니다.
구현체(DB/검색 엔진)는 생략하고, **결합 흐름**만 이해하는 용도로 사용합니다.

```python
"""
목적: 키워드/벡터 결과를 간단히 결합한다.
설명: RRF 방식으로 순위를 합산한다.
디자인 패턴: Strategy
"""

from collections import defaultdict
from dataclasses import dataclass


@dataclass(frozen=True)
class Item:
    """검색 결과 아이템."""

    doc_id: str
    score: float


def rrf_fuse(lists: list[list[Item]], k: int = 60, top_k: int = 5) -> list[Item]:
    """RRF 방식으로 여러 리스트를 결합한다."""
    scores: dict[str, float] = defaultdict(float)
    for items in lists:
        for rank, item in enumerate(items, start=1):
            scores[item.doc_id] += 1.0 / (k + rank)
    ranked = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    return [Item(doc_id, score) for doc_id, score in ranked[:top_k]]
```

---

## 6. 설계 시 고려해야 할 질문

- 키워드 검색의 기준은 무엇인가?
- 벡터/키워드 점수 스케일을 어떻게 정규화할 것인가?
- 결합 전략을 어떤 기준으로 선택할 것인가?
- 재정렬(LLM/크로스 인코더)을 어디까지 적용할 것인가?
- 메타데이터 필터를 두 검색기에 동일 적용하는가?

---

## 7. 흔한 실수

- 두 점수 스케일을 맞추지 않아 결과가 편중됨
- 메타데이터 필터를 한쪽에만 적용해 품질이 흔들림
- Top-K를 과도하게 크게 설정해 비용이 급증함

---

## 8. 체크리스트

- 하이브리드 검색이 필요한 이유가 명확한가?
- 점수 정규화와 결합 전략이 문서화되었는가?
- 메타데이터 필터가 양쪽 검색기에 동일 적용되는가?
- 재정렬 범위와 기준이 정의되었는가?
